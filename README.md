# 第１章
## 1.3章
・松本ひろゆき氏により開発されたオブジェクト思考スクリプト言語
・Rubykは複数の処理系を使用しており代表的なのはMRI
※処理系とは処理系として使用されているものでRubyのコードを読み込んで実行するもの
## 1.4章
・mac osでのインストール方法は複数ある
・ruby -vでインストールされているバージョンをしることができる
・osに標準で装備されているものは古いバージョンのものが多いのであまり使用しない
・開発の現場ではそれぞれ違ったバージョンを使用する時がありその場合はrbenv,RVMなどを使用すると複数のバージョンをインストールでき簡単に切り替えることができる
・Dockerを使用する方法もある
## 1.5章
・筆者おすすめの設定がQiitaに載っている
やっていなかったこと
・複数行の一括コメントアウト、コメント解除
選択してコマンド+/でコメントアウト、解除できる

・短形選択・短形編集
［Shift］＋［Option］＋［Command］＋矢印キー　


##  1.6章
・rubyを実行する方法はirbやファイルで使用する方法がある
・ファイルの実行方法　ruby 任意のファイル名


## 1.8章
・公式リファレンスを参照

## 1.9章
１章のまとめ
・本書の概要
・rubyについて
・Rubyのインストール
・editについて
・rubyを動かしてみる
・本書のサンプルコード
・公式リファレンスについて

# 第２章

## 2.2章
・数字やnillを含めて全てがオブジェクト

##2.2章
・メソッドの呼び出し方法
オブジェクト.メソッド（引数）

オブジェクト.メソッド
・引数の括弧も省略できる
・引数は何個でもつけれる

・改行が文の区切り
・一行に複数の文を含めたい場合は;を使用する
1.tos;nil.tos;10.to_s(16)
・文を途中が明らから場合は改行しても良い
・/を使うと文がまだ続くことを明示的に示すことができる

・コメントは#を使う
=beginと=endでは複数行で使用できる　※正しあまり使わない

・予約後は識別子として使用できない

・ソースコードに直接埋め込むことができる値のことをリテラルという
123,"hello",[1,2,3]

・変数名　= 式や値で変数に値を入れれる
・アルファベット以外も変数名として使用できる一度に複数の変数に値を入れることができる
a,b = 1,2
・変数名の先頭に_を使用できるがあまり使わない

・＝を使って複数の変数に値を入れれるが参照方法に注意が必要

## 2.3章
・文字列は'’または""で囲むことで使用する
・文字列に改行文字を含みたいときは""を使用する
・式展開を使用する場合は""を使用する

## 2.4章
・数値を見やすくするために_を使用して区切ることができる

## 2.5章
・falseとnil以外は真
・if文は最後に実行されたものを戻り値として返す
・elseがなくどの条件にも該当しない場合はnilを返す

## 2.6章
・メソッド名も変数名も同じ命名規則
・メソッドも最後に実行されたものが戻り値になる　そのためreturnは不要
・returnはメソッドの途中で脱出する際に使われる


## 2.8章
・%q! = シングルクオート
・%Q! = ダブルクオート
・%$! = ダブルクオート


## 2.9章
・それぞれの基数指示子を先頭につけると整数で表せることができる
・１０進数はつけてもつけなくても整数で表せる


## 2.10章
・&&や｜｜を使った場合戻り値はnillが返ってくる場合がある
・and,not,prは優先順位が低い
・複数の値を比較する場合はcase文を使うのが良い
・:を使っていif文の代わりに使用できる

## 2.11章
・引数にデフォルト値を設定すれば引数を呼び出さなくても使用できる
・デフォルト値には変動する値を入れることっもできる
・メソッドに？を使うと真偽値を返すことができる
・！を使用すると元の文字列にもメソッドの影響を与える
・変数には！や？を使うことはできない
・一行で終わるようなメソッドはendを省略することができる

## 2.12
・エイリアスメソッドとは全く同じ挙動をするメソッドのこと
・擬似変数に値を入れるとエラーになる
・putsメソッドは改行を加えて戻り値はnillを返す
・printメソッドは改行を加えずに戻り値はnillを返す
・pメソッドは改行を加えるが戻り値はオブジェクトそのもの
・ppメソッドは内容を見やすく表示する

# 3章
## 3.2章
・minitstを使用してテストの自動化を行う
・実行方法は１、テストコードを書く　２、実行する　３、実行結果をチェックする
・testコードはtestで始まったり終わったりする名前をつける
・asseert_equal 期待する結果　テストの対象となる値や式
assert_equal a,b  aとbが等しければpassする
assert a 真であればパスする
refute a 偽であればパスする
・実行方法　ruby sample_test.rb
・検証する前のエラーはErrorと出る

# 第４章
## 4.1章
・RGBカラー３色の色を数値化したもの
・to_hexメソッドは１０進数を１６進数に変換する　因数をつけると複数の値を変換できる

## 4.2章
・配列は数値に限らずどんなオブジェクトでも格納できる
・異なる値でも格納できる
・配列の中に配列も可能
・配列に要素を入れるとき指定していない数字を飛ばして入れるとnillが入る
・配列の特定の要素を消したいときはdelete_at(n)を使用する
・右辺に配列を指定することで多重代入をすることができる

## 4.3章
・ブロック
numbers.each do |n|
 sum +=n
end
・doからendまでをブロックという
・nはブロックパラメータ　eachメソッドから取り出されてた値が入る
・each分の様に取り出して削除したい場合はdelete_if文を使う
・do,endの代わりに{}を使用できる　一行でコンパクトに書きたいときに使用する

## 4.4章
・mapメソッド　配列を処理した結果を新しい配列に入れる
・selectメソッド　配列を評価し、その戻り値で新しい配列を作成する　真の値
・rejectメソッド　偽の場合
・findメソッド　　戻り値が真になった最初の値を返す
・sumメソッド　要素の合計を求める
配列の要素連結して一つの文字列にしたい場合、joinメソッドを使用する

##　4.5章
・範囲オブジェクト
最後の値を含む　1..5
最後の値を含まない 1...5
・以上以下のときは範囲オブジェクトを使用するとシンプルに書ける
・case文での使用できる

## 4.7章
・添え字を２つ使うと長さを指定して取得できる
・values_atを使うと複数の添え字を使用できる
・lastメソッドを使用すると最後の値を使用できる　引数を指定すると引数の数だけ値を取得できる
・firstはlastの反対
・配列の結合にはconcat（破壊メソッド）と+がある
・|,-,&で和集合、差集合、積集合を得れる
・多重代入に*を使うと残りの値を配列として受け取れる
・残りの値を無視したい場合は*だけでいける
・引数に可変長引数を使用したいときは引数の前に*をつける
・chartメソッドで文字列を分解して配列に入れれる
・splitを使用すると引数で指定した区切り文字で配列に入れれる
・Array.newで配列を作れる　デフォルト値は引数で指定する　ブロックも使用できる
・デフォルト値を指定すると一つの値を変更すると他の値も変更される

## 4.8章
・添え字の繰り返しにはwith_indexメソッドを使用する

## 4.9章
・範囲オブジェクトは終わりの文字、始まりの文字を指定しなくても使用できる

## 4.10章
・timesメソッド　配列を使用しない繰り返し
・uptoメソッド　一つずつ数値を増やしたい場合に使用する
・downtoメソッド　逆に減らしたい時に使用する
・stepメソッド　　要素を飛ばして増やしたい時
・while文　指定した値が真の時に繰り返す　until文は偽の時
・再起処理　メソッドの中でメソッドを呼び出す

## 4.11章
・breakメソッド　繰り返し処理を脱出したい時に使用する
・breakメソッドは一つ外側にしか脱出できない、一気に脱出するには catchとthrowメソッドを使う
・returnはメソッドの脱出、breakは処理からの脱出
・nextは処理を中断して次の処理を実行できる
・redoメソッドは最初に戻る


#　5章
・ハッシュはキーと値からなる
・同じ名前のものは最後の値が使われる
・=>や:で区切る
・キーを追加するときにすでに同じものがあると上書きされる
・eachメソッドを使用してキーと値を取り出せる
・シンボルは:に続けて使用する
・シンボルは整数として認識される
・メモリ効率が良い
・高速に値を比較できる
・破壊できない
・ハッシュのキーによく使用される

## 5.4章
・キーをシンボルにするとキー：値
・両方シンボルではキー：；値
・キーワード引数で引数の意味がわかりやすくなる

## 5.6章
・keyメソッドはハッシュのキーのみを配列として返す
・valuesメソッドはハッシュの値を配列として返す
・has_key？メソッドはハッシュのなkに指定したキーがあるか存在するかどうか確認するメソッド
・**をつけるとハッシュの中でハッシュを使用できる
・mergeメソッドでも上記と同じ動きをする
・**引数を使用すると定義していないキーワードでもエラーにならない
・to_aでハッシュを配列に、to_hで配列をハッシュにできる

## 5.7章
・識別子もシンボルとして使用できる
・識別子として無効な文字列は''で囲むと有効になる
・to_symメソッドで文字列をシンボルに変換可能
・シンボルを文字列はto_s

#　第６章
## 6.2章
・正規表現を使って簡単に文字を抜け出せる
・//で囲って使用する


## 6.3章
・Rubularで正規表現をチェックしながら使用できる
・メソッドと正規表現を繰り合わせることができる


##　6.5章
・正規表現を作成するメソッドはさま様ある
・Regexp.new の引数に正規表現を渡すパターン
・%rを使う方法
・正規表現のオプション
・i　大文字小文字をみしする
・m .が改行文字にもマッチする
・x 空白文字がみしされ #でコメントが書ける
・オプション同士は併用して使用できる

#　第７章
・ハッシュはもろく壊れやすくなりがち
・大きなプログラムだとハッシュの使用しない方が良い
・クラスを使うことでデータとメソッドの整理がしやすい
・オブジェクトが保持しているデータをステートという

## 7.3章
・newメソッドはinitializeメソッドが呼ばれる
・メソッドの前にself.を使うとクラスメソッドになる
・クラスには定数を定義できる

## 7.5章
・selfは省略可能
・ただしセッターメソッドの呼び出し時はselefを使う
・クラスメソッドをインスタンスメソッド内部から呼び出す場合は　クラス名.メソッド名にする


## 7.6章
・「サブクラスはスーパークラスの一種」が違和感がない時適切な継承関係である
・サブクラスはスーパークラスの性質を特化させたもの
・スーパークラスはサブクラスの性質を凡化させたもの
・Rubyは単一継承（継承できるスーパークラスが一個）
・オブジェクトクラスのスーパークラスはBasicオブジェクト
・「オブジェクトクラスはベーシックオブジェクトの一部」
・オブジェクトのクラスを調べるにはclassメソッドを使用する
・instance_of?も同じ意味
・継承関係を含めて調べる場合はis_a?メソッド
・継承元を指定しない場合はオブジェクトクラスが継承されるが < を使って
任意のクラスを継承することができる
・クラス内でスーパークラスと同名のメソッドを定義することでオーバーライドを使用できる
・クラスを継承するとメソッドも継承される

## 7.7章
・publicメソッド　外部から呼び出される　initializeメソッド以外のメソッドはpiblicメソッド
・privateメソッド　クラス内部でしか使用できない　サブクラスは呼び出される
・クラスメソッドはprivateメソッドの下に定義しても使えない　
・protectedメソッド　privateメソッドの機能にレシーバーをつけたもの

## 7.8章
・クラス名::定数名でクラスの外部から呼び出される
・定数はクラスの外部から変更可能　変更させないためにfreezeメソッドを使用する
・定数は破壊メソッドで破壊できてしまうので注意

## 7.9章
・クラスインスタンス変数　クラス自信を＠変数に入れた時にできる　＠name = 'NAME'
・グローバル変数　$から始まる変数　どこからでも呼び出し可能


##　7.10章
・自分でエイリアスメソッドを作成可能　alias 新しい名前　元の名前
・ただし先に元のメソッドを定義していないといけない
・メソッドの削除　undef メソッド名
・クラスの中にクラスを定義して名前空間を作る　参照する場合は親クラス::入れ子のクラス
・演算子を自分で再定義可能
・== 人の目で見て同じであればtrue
・equal? オブジェクトidが同じであればtrue 再定義不可
・rubyのクラスは変更に対してopen
・この特性を利用して挙動を変更させることをモンキーパッチという

# ８章

## 8.2章
・モジュールは継承できない
・インスタンスの作成もできない

## 8.3章
・モジュールは継承関係を気にせず使用できる
・is-aの関係が成り立たない場合に使用する
・extendを使用するとモジュール内のメソッドをそのクラスのクラスメソッドとしてしようできる


## 8.5章
・include？(モジュール名)でモジュールがインクルードされているかわかる
・include_modulesで配列で返す
・ancestorsではスーパークラスの情報も返す
・Enumerableモジュールにはmap,select,find,countメソッドが定義されている
・Enumerableモジュールを使うにはeachメソッドを定義している必要がある
・Comparableモジュールは比較演算子を可能にする
・Comparableモジュールを使う条件は<=>(宇宙船演算子)を定義していること
・Kernelモジュールはputs,p,pp,print,require,loopなどがある
・KernelモジュールはオブジェクトクラスがKernelモジュールをインクルードしているのでどこでも使える

## 8.6章
・名前交換は複数のクラスで名前が被ったときにどのモジュールのクラス判断するのに使われる
・グループ分け、カテゴリ分けにも使用される


## 8.7章
・モジュール名.メソッド名で単体で使用できる
・特異メソッドとミックインとしても使用するにはmodule_functionメソッドを使用する
・モジュールにも定数を指定できる
・Mathメソッド　特異メソッド、ミックスインとしても使用できる


## 8.8章
・モジュール自体のデータを保持する方法はクラスインスタンス変数と一緒


## 8.9章
・メソッドの探索の順番は階層の浅いものから探索される
・ミックスインはmoduleを使用する方法とprependを使用する方法がある
・refinementsを使用すると範囲を指定できる

# ９章
## 9.1章
・例外処理は読みやすい堅牢はプログラムにつながる

## 9.2章
・rubyのバージョンによってエラー文の構成が変わる
・例外オブジェクトから情報を引き出すにはmessageやbacktraceメソッドを使用する
・例外オブジェクトを単体、複数指定して処理を続行させる方法もある
・通常のエラーはStandardErrorクラス　rescue文にクラスを指定しなかった場合に補足されるもの
・それ以外は通常は発生しない特車なエラー
・クラスを指定するときにExceptionを指定するのは避ける
・クラスを指定する時はサブクラスを最初に、スーパースラスを後に記述する

## 9.3章
・raiseメソッドで意図的に例外を発生させる
・文字列は省略しない方がデバックしやすくなる


## 9.4章
・rescue文はフレームワークが例外の補足をしてくれるためあまり使わない
・やむおえず使用する場合はクラス名、エラーメッセージ、バックトレースの情報は出力するべき
・full_messageメソッドを使用すると一度に取り出せる
・elseを使ってプログラムを終了させる


## 9.6章
・ensureで例外の発生の有無に関わらずに実行される
・例外が発生しない場合最後に実行されたものが戻り値になる
・rescueを使用してbeginとendを省略できる
　例外が発生しそうな処理　rescue 例外が発生した時の戻り値
・$1 最後に発生した例外
・$@ バックトレース
・メソッド全体が例外処理の場合はbeginとend省略可能　do/endも同じく

## １０章
・yield書いたところでブロックに書いた処理が実行される
・ブロックがない場合はエラーになる
・block_givenで条件分岐させて有無によって動作を変える
・引数が多かったり少なくてもエラーにはならない
・yieldではなくcallメソッドを使用しても呼び出せる
・ブロックを引数にできる（一つだけ、他の引数がある場合は最後に引数を持ってくる）
・メリットはブロックを他のメソッドに引き渡せる、ブロックに操作を実行できる

## 10.3章
・Procクラス　ブロックをオブジェクト化するためのクラス
・Procオブジェクトは.newを使用して作成する　procメソッドでも作成できる
・callメソッドで実行する
・ブロックの代わりにProcオブジェクトを引数に渡すことでブロックを書かないで済む
・引数に&をつけずただの引数として使用せることでブロックを引数に指定したときの一個しか使用できな制限を無しにできる
・=> ラムダを作成するためのもの
・ラムダはnewと比べて引数の個数にうるさい　同じ個数でなければならない

## 10.5章
・procオブジェクトの呼び出し方法
call
yield
.()
[]
===
・＆の働きは右辺のオブジェクトにto_procメソッドを呼び出しその戻り値をブロックを利用するメソッドに与えている

# 第１１章
・パターンマッチはruby３.０で新しく導入されたもの
case 式
in パターン１
　マッチした時の処理
in パターン２
１にマッチせず２にマッチした時の処理
・パターンマッチではelsifを使わない
・valueパターンマッチ　パターンマッチが一つもないとエラーになる
・variableパターン　ローカル変数の代入と宣言を同時に行う
・arrayパターン []を使って構造パターンを指定するもの　
・ハッシュパターn {}を使ってマッチさせるパターン
・asパターン　=>を利用してマッチしたオブジェクトに変数に代入するパターン
・alternativeパターン　|を使用してどれか一つにマッチすれば実行されるパターン
・findパターン　*を使用して任意の要素にマッチする値を実行するパターン

## 11.5章
・ガード式　in パターン　if (またはunless) 条件式
・case文を省略して一行で書くことも可能


# 12章
・バックトレースは上に行くほどエラーに近い
・形式によって若干は異なるが大体一緒

## 12.３章
・組み込みライブラリ以外にもgemやフレームワーク由来の例外クラスがあるが基本的には一緒


## 12.4章
・printメソッド　値を確認するのに使う pやputsの方をよく使う　条件分岐で意図した条件にマッチしているかの確認にも使用　putsは戻り値がnillになる

・tapメソッド　コードの途中の値を確認できる
・logger.debag ログに情報を出力する
・debug.gem 対話的にデバックをできる　今後さらに発展予定

## 12.5章
・irbやconsoleを使ってコードの確認をする
・困った時は公式ドキュメントを参照
・issueトラッキングシステムでは過去の問題を見ることができる　ただし英語
・ライブラリのコードを読むことも有効
・テストコードを書いた方が時間の短縮になる　効率的

# 13章
##　13.2章
・Timeクラスはrequireを使わずに使用できる

## 13.3章
・Fileクラス、Dirクラスはrequireなしで使える
・FileUtileモジュールは基本的なファイル操作を集めたモジュール

## 13.4章
・csv,json,yamlの形式で読み書きするライブラリもある

## 13.5章
・組み込み定数　最初からオブジェクトクラスに定義されている定数

## 13.6章
・バージョンアップに伴い非推奨の機能があり、警告が出る
・使う場合は-w：deprecatedというオプションを使用する

## 13.7章
・eval,バックオートリテラル、sendメソッドは自由に値を変更できるのでセキュリティ上での注意が必要

## 13.8章
・Rake ビルドツール以外にもまとまった処理を実行するためのツールとして使われる
・ターミナルでrake ~と打てば実行される

## 13.9章
・bundleで大量ほgemを使用できる
・Gemfile .lockは自動的に更新されるファイル　安易に変更してはいけない　自分がインストールしたgemの情報を見れる

## 13.10章
・Typeprofで型情報を自動生成できる
・テストコードや実行コードがないと自動生成できない
・rubyには型検査をする機能はないのでgemを使用する
・steep gem 
・vsコードの拡張機能も型検査の一種


## 13.11章
・railsでは自動的にrequireされるのであまり書くことはない
・rubyとrailsでルールの違いがある
・ruby == rails ではない


























